# This workflow builds and publishes the .NET application for multiple platforms
# and uploads the binaries as downloadable artifacts

name: Build and Publish Cross-Platform

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        os: [windows, linux]
        include:
          - os: windows
            runtime: win-x64
            artifact-name: conductor-health-check-windows
            file-extension: .exe
          - os: linux
            runtime: linux-x64
            artifact-name: conductor-health-check-linux
            file-extension: ""

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Restore dependencies
      run: dotnet restore Conductor_Health_Check.sln

    - name: Run tests
      run: dotnet test Conductor_Health_Check.sln --no-restore --verbosity normal

    - name: Publish application
      run: |
        dotnet publish Conductor_Health_Check/Conductor_Health_Check.csproj \
          --configuration Release \
          --runtime ${{ matrix.runtime }} \
          --self-contained true \
          --output ./publish/${{ matrix.os }} \
          -p:PublishSingleFile=true \
          -p:PublishTrimmed=false

    - name: Create release directory
      run: |
        mkdir -p ./release
        cp -r ./publish/${{ matrix.os }}/* ./release/

    - name: Create Linux service installation script
      if: matrix.os == 'linux'
      run: |
        cat > ./release/install-service.sh << 'EOF'
        #!/bin/bash
        set -e

        # Must run as root
        if [ "$(id -u)" -ne 0 ]; then
          echo "This script must be run as root" >&2
          exit 1
        fi

        # Determine installation location
        INSTALL_DIR="/opt/conductor-health-check"
        SERVICE_NAME="conductor-health-check"
        EXECUTABLE="Conductor_Health_Check"
        CURRENT_DIR=$(pwd)

        echo "Installing/Updating Conductor Health Check as a systemd service..."

        # Check if service exists and is running
        SERVICE_EXISTS=false
        SERVICE_RUNNING=false
        
        if systemctl list-units --full -all | grep -Fq "$SERVICE_NAME.service"; then
            SERVICE_EXISTS=true
            echo "Service already exists, preparing for update..."
            
            if systemctl is-active --quiet "$SERVICE_NAME"; then
                SERVICE_RUNNING=true
                echo "Service is currently running, stopping it for update..."
                systemctl stop "$SERVICE_NAME"
            fi
        fi

        # Create installation directory
        mkdir -p $INSTALL_DIR
        
        # Backup existing appsettings.json if it exists during an update
        if [ "$SERVICE_EXISTS" = true ] && [ -f "$INSTALL_DIR/appsettings.json" ]; then
            echo "Backing up existing appsettings.json..."
            cp "$INSTALL_DIR/appsettings.json" "$INSTALL_DIR/appsettings.json.backup"
        fi
        
        # Copy all files to installation directory
        # Use rsync if available for better handling of file updates, otherwise use cp
        if command -v rsync >/dev/null 2>&1; then
            echo "Using rsync for file copy..."
            rsync -av --exclude='install-service.sh' "$CURRENT_DIR/" "$INSTALL_DIR/"
        else
            echo "Using cp for file copy..."
            # Remove the install script from destination to avoid copying it
            find "$CURRENT_DIR" -mindepth 1 -maxdepth 1 ! -name 'install-service.sh' -exec cp -r {} "$INSTALL_DIR/" \;
        fi
        
        # Handle appsettings.json configuration
        if [ "$SERVICE_EXISTS" = true ] && [ -f "$INSTALL_DIR/appsettings.json.backup" ]; then
            # Check if user modified appsettings.json in the extracted folder
            if ! cmp -s "$CURRENT_DIR/appsettings.json" "$INSTALL_DIR/appsettings.json"; then
                echo "WARNING: You have modified appsettings.json in the extracted folder."
                echo "Current service configuration will be preserved, but your extracted changes will be ignored."
                echo "If you want to use the modified configuration, please:"
                echo "  1. Stop this installation (Ctrl+C)"
                echo "  2. Manually merge your changes into the existing service config at:"
                echo "     $INSTALL_DIR/appsettings.json.backup"
                echo "  3. Re-run this script"
                echo ""
                read -p "Continue with existing service configuration? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    echo "Installation cancelled by user."
                    # Restore original state
                    if [ -f "$INSTALL_DIR/appsettings.json.backup" ]; then
                        mv "$INSTALL_DIR/appsettings.json.backup" "$INSTALL_DIR/appsettings.json"
                    fi
                    exit 1
                fi
            fi
            echo "Restoring existing appsettings.json configuration..."
            mv "$INSTALL_DIR/appsettings.json.backup" "$INSTALL_DIR/appsettings.json"
            echo "Your existing service configuration has been preserved."
        elif [ "$SERVICE_EXISTS" = false ]; then
            echo "New installation: Using appsettings.json"
            if ! cmp -s "$CURRENT_DIR/appsettings.json" "/dev/null" 2>/dev/null; then
                echo "Note: Using the appsettings.json from the extracted folder."
            fi
            echo "Please review and edit /opt/conductor-health-check/appsettings.json to configure your settings."
        fi
        
        # Ensure the executable has proper permissions
        chmod +x $INSTALL_DIR/$EXECUTABLE
        
        # Create or update systemd service file
        cat > /etc/systemd/system/$SERVICE_NAME.service << 'SERVICEEOF'
        [Unit]
        Description=Conductor Health Check Service
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        WorkingDirectory=/opt/conductor-health-check
        ExecStart=/opt/conductor-health-check/Conductor_Health_Check
        Restart=always
        RestartSec=10
        SyslogIdentifier=conductor-health-check
        User=root
        Environment=ASPNETCORE_ENVIRONMENT=Production
        Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false
        Environment=HOME=/root
        Environment=DOTNET_CLI_HOME=/root
        Environment=DOTNET_ROOT=/usr/share/dotnet
        StandardOutput=journal
        StandardError=journal
        KillSignal=SIGINT
        TimeoutStopSec=30

        [Install]
        WantedBy=multi-user.target
        SERVICEEOF

        # Reload systemd daemon
        systemctl daemon-reload
        
        # Enable the service if it wasn't already enabled
        if ! systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
            echo "Enabling service..."
            systemctl enable "$SERVICE_NAME"
        fi
        
        # Start the service
        echo "Starting service..."
        systemctl start "$SERVICE_NAME"
        
        # Wait a moment and check if service started successfully
        sleep 2
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            if [ "$SERVICE_EXISTS" = true ]; then
                echo "Service updated and started successfully!"
            else
                echo "Service installed and started successfully!"
            fi
        else
            echo "Warning: Service may not have started correctly. Check status with: systemctl status $SERVICE_NAME"
        fi
        
        echo ""
        echo "Management commands:"
        echo "  Check status: sudo systemctl status $SERVICE_NAME"
        echo "  Start service: sudo systemctl start $SERVICE_NAME"
        echo "  Stop service: sudo systemctl stop $SERVICE_NAME"
        echo "  Restart service: sudo systemctl restart $SERVICE_NAME"
        echo "  View logs: sudo journalctl -u $SERVICE_NAME -f"
        echo "  View recent logs: sudo journalctl -u $SERVICE_NAME --since '10 minutes ago'"
        echo ""
        echo "To uninstall the service:"
        echo "  sudo systemctl stop $SERVICE_NAME"
        echo "  sudo systemctl disable $SERVICE_NAME"
        echo "  sudo rm /etc/systemd/system/$SERVICE_NAME.service"
        echo "  sudo rm -rf $INSTALL_DIR"
        echo "  sudo systemctl daemon-reload"
        echo ""
        echo "Installation directory: $INSTALL_DIR"
        echo "Service logs: sudo journalctl -u $SERVICE_NAME"
        EOF
        
        chmod +x ./release/install-service.sh
        
    - name: Create zip archive for release
      run: |
        cd ./release
        if [ "${{ matrix.os }}" == "windows" ]; then
          zip -r ../conductor-health-check-${{ matrix.os }}-${{ github.sha }}.zip .
        else
          tar -czf ../conductor-health-check-${{ matrix.os }}-${{ github.sha }}.tar.gz .
        fi
        cd ..
        
    - name: List published files
      run: ls -la ./release/

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}
        path: ./release/
        retention-days: 30

    - name: Upload release archives
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}-archive
        path: |
          conductor-health-check-${{ matrix.os }}-${{ github.sha }}.zip
          conductor-health-check-${{ matrix.os }}-${{ github.sha }}.tar.gz
        retention-days: 30

  create-release-info:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
    - name: Create Release Info
      run: |
        echo "## ðŸš€ Build Artifacts Available" > release-info.md
        echo "" >> release-info.md
        echo "The following artifacts have been built and are available for download:" >> release-info.md
        echo "" >> release-info.md
        echo "- **Windows (x64)**: conductor-health-check-windows" >> release-info.md
        echo "- **Linux Ubuntu (x64)**: conductor-health-check-linux" >> release-info.md
        echo "" >> release-info.md
        echo "### How to run:" >> release-info.md
        echo "1. Download the appropriate artifact for your platform" >> release-info.md
        echo "2. Extract the files" >> release-info.md
        echo "3. Run the executable:" >> release-info.md
        echo "   - Windows: \`Conductor_Health_Check.exe\`" >> release-info.md
        echo "   - Linux: \`./Conductor_Health_Check\` (make sure it's executable: \`chmod +x Conductor_Health_Check\`)" >> release-info.md
        echo "" >> release-info.md
        echo "The application will start on http://localhost:5000 by default." >> release-info.md
        
    - name: Upload Release Info
      uses: actions/upload-artifact@v4
      with:
        name: release-info
        path: release-info.md

  create-github-release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts

    - name: Display structure of downloaded files
      run: ls -la ./artifacts/

    - name: Generate release tag
      id: tag
      run: |
        TAG="v$(date +'%Y.%m.%d')-${GITHUB_SHA:0:7}"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Generated tag: $TAG"

    - name: Set current date
      id: date
      run: echo "BUILD_DATE=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.tag }}
        release_name: "Release ${{ steps.tag.outputs.tag }}"
        body: |
          ðŸš€ Conductor Health Check Release
          This release contains cross-platform binaries for the Conductor Health Check application.
          
          Available Downloads:
          - Windows (x64): Download the .zip file
          - Linux (x64): Download the .tar.gz file
          
          How to run:
          1. Download the appropriate file for your platform
          2. Extract the archive
          3. Run the executable:
             - Windows: Conductor_Health_Check.exe
             - Linux: ./Conductor_Health_Check (make executable first: chmod +x Conductor_Health_Check)
          
          Installing as Linux Service:
          For Linux users, a service installation script is included. To install as a systemd service:
          1. Extract the Linux artifact
          2. Make the script executable: chmod +x install-service.sh
          3. Run with sudo: sudo ./install-service.sh
          4. The service will be installed, enabled and started automatically
          
          Service management commands:
          - Check status: sudo systemctl status conductor-health-check
          - Start service: sudo systemctl start conductor-health-check
          - Stop service: sudo systemctl stop conductor-health-check
          - View logs: sudo journalctl -u conductor-health-check -f
          
          The application will start on http://localhost:5000 by default.
          
          Built from commit: ${{ github.sha }}
          Build date: ${{ steps.date.outputs.BUILD_DATE }}
        draft: false
        prerelease: false

    - name: Upload Windows Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./artifacts/conductor-health-check-windows-archive/conductor-health-check-windows-${{ github.sha }}.zip
        asset_name: conductor-health-check-windows-${{ steps.tag.outputs.tag }}.zip
        asset_content_type: application/zip

    - name: Upload Linux Release Asset
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: ./artifacts/conductor-health-check-linux-archive/conductor-health-check-linux-${{ github.sha }}.tar.gz
        asset_name: conductor-health-check-linux-${{ steps.tag.outputs.tag }}.tar.gz
        asset_content_type: application/gzip
